# Hexãƒ‘ãƒƒã‚±ãƒ¼ã‚¸

```elixir
Mix.install([
  {:jason, "~> 1.4"},
  {:croma, "~> 0.11.3"},
  {:httpoison, "~> 2.1"},
  {:meck, "~> 0.9.2"}
])
```

## Hexãƒ‘ãƒƒã‚±ãƒ¼ã‚¸

Elixirã«ã¯[Hex](https://hex.pm/)ã¨ã„ã†ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒã‚ã‚‹ã€‚

Elixirã§ã¯`mix`ã¨ã„ã†ãƒ„ãƒ¼ãƒ«ã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†ã‚’ã™ã‚‹ã€‚

* [ã“ã®ã‚ˆã†ã«](https://hex.pm/docs/usage)`mix.exs`ã¨ã„ã†ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå®šç¾©ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¾å­˜ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’è¨˜è¿°ã™ã‚‹

Erlangå‘ã‘ã®Hexãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚‚ã‚ã‚Šã€Elixirã§ã‚‚å•é¡Œãªãä½¿ç”¨å¯èƒ½ã€‚

ã“ã“ã§ã¯ã„ãã¤ã‹ã®Hexãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ç´¹ä»‹ã™ã‚‹ã€‚

* [Jason](https://hexdocs.pm/jason/): é«˜é€ŸãªJSONãƒ‘ãƒ¼ã‚µãƒ¼ãƒ»ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼
* [Croma](https://hexdocs.pm/croma/api-reference.html): Antikytheraå‰µå§‹è€…ã®æ–¹ãŒä½œæˆã—ãŸã€å‹ãƒ™ãƒ¼ã‚¹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ãŸã‚ã®ãƒã‚¯ãƒ­é›†
* [meck](https://hexdocs.pm/meck/): Erlangå‘ã‘ã®ãƒ¢ãƒƒã‚­ãƒ³ã‚°ãƒ©ã‚¤ãƒ–ãƒ©ãƒª

ãªãŠã€[Antikythera](https://hexdocs.pm/antikythera/api-reference.html)ã‚‚Hexãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ã—ã¦å…¬é–‹ã•ã‚Œã¦ã„ã‚‹ã€‚ãŒã€ã“ã“ã§ã¯æ‰±ã‚ãªã„ã€‚

## Livebookä¸Šã§ã®ä½¿ç”¨

å‹•çš„ã«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚’è¡Œã†ãŸã‚ã€[`Mix.install/2`](https://hexdocs.pm/mix/1.14/Mix.html#install/2)ã‚’åˆ©ç”¨ã™ã‚‹ã€‚

Livebookã§ã¯ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å°‚ç”¨ã®ã‚»ãƒ«ãŒãƒãƒ¼ãƒˆãƒ–ãƒƒã‚¯ä¸Šéƒ¨ã«é…ç½®ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ãã“ã«å¿…è¦ãªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’è¿½åŠ ã—ã¦setupãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã€‚

## Jason

* `Jason.decode/1` ã§JSONå½¢å¼ã®æ–‡å­—åˆ—ã‚’Elixirã®å€¤ã«ãƒ‘ãƒ¼ã‚¹ã™ã‚‹
  * `Jason.decode!/1` ã¯ãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼
* `Jason.encode/1` ã§Elixirã®å€¤ã‚’JSONæ–‡å­—åˆ—ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹
  * `Jason.encode!/1` ã¯ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼

Webã‚µãƒ¼ãƒãƒ¼ã§ã¯HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚„ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®bodyã«å¯¾ã—ã¦é©ç”¨ã™ã‚‹ã“ã¨ãŒå¤šã„ã€‚

```elixir
json = """
{
  "x": 0,
  "y": "a",
  "array": [0, 1, 2],
  "nested": {
    "inner": {}
  }
}
"""

{:ok, map} = Jason.decode(json)
map
```

```elixir
File.read!("./resources/7/test.json")
|> Jason.decode!()
```

```elixir
{:error, reason} = Jason.decode("{[]}")
```

<!-- livebook:{"continue_on_error":true} -->

```elixir
result = Jason.decode!("{[]}")
# => Jason.DecodeError
```

```elixir
{:ok, json} = Jason.encode(%{a: 0})
json
```

## Croma

* Elixirã§å‹ãƒ™ãƒ¼ã‚¹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’è¡Œã†ã®ã‚’æ¥½ã«ã™ã‚‹ãƒã‚¯ãƒ­é›†

### ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã¤ãStructã®å®šç¾©

```elixir
# ä¾‹1. ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã¤ãStructã‚’å®šç¾©
# new/1 ã‚„ new!/1 é–¢æ•°ã§Structã‚’ç”Ÿæˆã™ã‚‹æ™‚ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®validationãŒè‡ªå‹•ã§è¡Œã‚ã‚Œã‚‹

defmodule TestStruct do
  # xã¯æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„
  use Croma.Struct,
    recursive_new?: true,
    fields: [
      x: Croma.Integer
    ]
end

defmodule OtherStruct do
  # xã¯æ•´æ•°ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„
  use Croma.Struct,
    recursive_new?: true,
    fields: [
      x: Croma.Integer
    ]
end
```

```elixir
TestStruct.new(%{x: 0})
```

<!-- livebook:{"continue_on_error":true} -->

```elixir
# xã®valueãŒæ•´æ•°ã§ã¯ãªã„ã®ã§å¤±æ•—
TestStruct.new(%{x: 1.0}
```

```elixir
# Structã®ç¨®é¡ã‚’è€ƒæ…®ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ
%TestStruct{x: x} = TestStruct.new!(%{x: 0})

x
```

<!-- livebook:{"continue_on_error":true} -->

```elixir
# Cromaã®ä½¿ç”¨ã«é–¢ã‚ã‚‰ãšã€ç•°ãªã‚‹Structã©ã†ã—ã¯ãƒãƒƒãƒã—ãªã„
%OtherStruct{x: x} = TestStruct.new!(%{x: 0})
# => MatchError
```

```elixir
# Structã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã‚ˆã‚Šè©³ç´°ã«å®šç¾©ã™ã‚‹ä¾‹

defmodule Food do
  # ç‰¹å®šã®atomã ã‘è¨±å¯
  defmodule Category do
    use Croma.SubtypeOfAtom, values: [:meat, :vegitable, :fruit]
  end

  # æ­£è¦è¡¨ç¾ã§é•·ã•1ï½50ã®æ–‡å­—åˆ—ã‚’è¨±å¯
  defmodule Name do
    use Croma.SubtypeOfString, pattern: ~r/\A.{1,50}\z/
  end

  use Croma.Struct,
    recursive_new?: true,
    fields: [
      category: Category,
      name: Name
    ]
end

defmodule Eater do
  # Food struct ã‚’å¼•æ•°ã«å–ã‚‹é–¢æ•°
  def eat(%Food{category: category, name: name}) do
    case category do
      :vegitable -> "I do not like #{name}, but I eat it..."
      _ -> "I love #{name}!"
    end
  end
end
```

```elixir
[
  %{category: :meat, name: "pork"},
  %{category: :vegitable, name: "tomato"},
  %{category: :fruit, name: "apple"}
]
|> Enum.map(&Food.new!/1)
|> Enum.map(&Eater.eat/1)
```

```elixir
# nameã®æ–‡å­—æ•°ãŒ50ã‚ˆã‚Šå¤§ãã„å ´åˆã«ã¯ã‚¨ãƒ©ãƒ¼
Food.new(%{
  category: :meat,
  name: "this meat is something having too long name and we cannot pronounce it"
})
```

```elixir
# nameã®æ–‡å­—æ•°ãŒ0ã®å ´åˆã«ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã‚ˆã†
Food.new(%{})
```

```elixir
# categoryã«æœªå®šç¾©ã®atomãŒæ¸¡ã•ã‚Œã‚‹å ´åˆã‚‚ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã“ã¨ã‚’ç¢ºã‹ã‚ã‚ˆã†
Food.new(%{})
```

### é–¢æ•°å®šç¾©ã«ãŠã‘ã‚‹åˆ©ç”¨ä¾‹

ã“ã¡ã‚‰ã¯å‚è€ƒã¾ã§ã«ã€‚

é–¢æ•°å®šç¾©æ™‚ã«é–¢æ•°ã®å‹ã‚¹ãƒšãƒƒã‚¯ã‚’ç°¡æ½”ã«è¡¨ã—ãŸã‚Šã€å¼•æ•°ã‚„è¿”ã‚Šå€¤ãŒæœŸå¾…ã—ãŸå‹ã§ã‚ã‚‹ã“ã¨ã®validationã‚’ã—ãŸã‚Šã§ãã‚‹ã€‚

* `def`ã«ä»£ã‚ã‚‹`defun`
* `defp`ã«ä»£ã‚ã‚‹`defunp`

```elixir
defmodule CromaTestModule do
  # CromaãŒæä¾›ã™ã‚‹ãƒã‚¯ãƒ­ã‚’åˆ©ç”¨ã™ã‚‹ãŸã‚ã«å¿…è¦
  use Croma

  @moduledoc """
  `defun`ã‚„`defunp`ã§å¼•æ•°ã«ç¶šã‘ã¦`:: type`ã®ã‚ˆã†ã«å‹ã‚’æ›¸ãã€‚
  `v[]`ã§å‹ã‚’å›²ã‚€ã¨ã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ æ™‚ã«å¼•æ•°ã®å‹ãŒä»•æ§˜ã«ã‚ã£ã¦ã„ã‚‹ã“ã¨ã®validationãŒè¡Œã‚ã‚Œã‚‹ã€‚

  è¿”ã‚Šå€¤ã‚‚åŒæ§˜ã«è¡¨ç¾ã™ã‚‹ã€‚

  `defun`ã‚„`defunp`ã§å¤šé‡å®šç¾©ã™ã‚‹éš›ã¯ã€ç„¡åé–¢æ•°ã®å¤šé‡å®šç¾©ã®ã‚ˆã†ãªæ›¸ãæ–¹ã‚’ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
  """

  # Elixiræ¨™æº–ã®è¨˜æ³•
  @spec add(integer, integer) :: integer
  def add(x, y) do
    x + y
  end

  # Cromaã‚’ä½¿ã£ãŸè¨˜æ³•(å‹ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ã)
  defun add_integers(x :: v[integer], y :: v[integer]) :: v[integer] do
    x + y
  end

  # Cromaã‚’ä½¿ã£ãŸè¨˜æ³•(å‹ã‚¹ãƒšãƒƒã‚¯ã®ã¿)
  defun add_integers_without_validation(x :: integer, y :: integer) :: integer do
    x + y
  end

  defun accept_hello_atom(value :: atom) :: Croma.Result.t(:hello, String.t()) do
    :hello -> {:ok, :hello}
    other_atom -> {:error, format_message(other_atom)}
  end

  defunp format_message(value :: v[atom]) :: v[String.t()] do
    "#{value} is not :hello atom"
  end
end
```

```elixir
CromaTestModule.add_integers(0, 1)
```

<!-- livebook:{"continue_on_error":true} -->

```elixir
CromaTestModule.add_integers(0.0, 1)
# => %RuntimeError{message: "validation error: x is not a valid integer"}
```

```elixir
CromaTestModule.add_integers_without_validation(0.0, 1)
```

```elixir
CromaTestModule.accept_hello_atom(:hello)
```

```elixir
CromaTestModule.accept_hello_atom(:world)
```

## meck

Erlangã®ãƒ¢ãƒƒã‚­ãƒ³ã‚°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã€‚

ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é–¢æ•°ã®æŒ¯ã‚‹èˆã„ã‚’å‹•çš„ã«å¤‰ãˆãŸã‚Šã€å¼•æ•°ã®ãƒ†ã‚¹ãƒˆã‚’è¡Œã£ãŸã‚Šã€å‘¼ã³å‡ºã—å›æ•°ã‚’è¨ˆæ¸¬ã—ãŸã‚Šã§ãã‚‹ã€‚

ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã§ã‚ˆãä½¿ç”¨ã•ã‚Œã‚‹ã€‚

ä¾‹ãˆã°å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã«ä¾å­˜ã™ã‚‹é–¢æ•°ãƒ»å‰¯ä½œç”¨ã®ã‚ã‚‹é–¢æ•°ã®ãƒ†ã‚¹ãƒˆã‚’è¡Œã„ãŸã„ã¨ãã€ãƒ¢ãƒƒã‚¯ã‚’ä½¿ç”¨ã—ãŸããªã‚‹ã€‚

* å¾Œã®`HttpBin.send_request/3`ã‚’ä½¿ç”¨ã—ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆå…ˆã®ã‚µãƒ¼ãƒãƒ¼ãŒãƒ€ã‚¦ãƒ³ã—ã¦ã„ã‚‹çŠ¶æ³ã®ãƒ†ã‚¹ãƒˆã‚’ã—ãŸã„
* å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ãŒãƒ€ã‚¦ãƒ³ã—ã¦ã„ã‚‹æ™‚(HTTP status 500ãŒè¿”ã‚‹ã¨ã™ã‚‹)ã®å‡¦ç†ãŒæœŸå¾…ã©ãŠã‚Šã‹ç¢ºã‹ã‚ãŸã„
  * ã—ã‹ã—ã€å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã‚’å®Ÿéš›ã«ãƒ€ã‚¦ãƒ³ã•ã›ã‚‹ã“ã¨ã¯ã§ããªã„
* ãã‚‚ãã‚‚ãƒ†ã‚¹ãƒˆã§ã€å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ã‚ŠãŸããªã„

ãƒ¢ãƒƒã‚¯ã‚’ä½¿ã†ã¨, é–¢æ•°å‘¼ã³å‡ºã—ã‚’ç›£è¦–ã™ã‚‹ã“ã¨ãŒã§ãã€å¿…è¦ãªã‚‰ã°åŒã˜ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ç•°ãªã‚‹æŒ¯ã‚‹èˆã„ã‚’ã™ã‚‹åˆ¥ã®é–¢æ•°ã«å·®ã—æ›¿ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

ã¤ã¾ã‚Šã€ä¸‹ã®å›³ã®ã‚ˆã†ã«ã‚ã‚‹ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®ã¨ãã ã‘`HttpBin.send_request/3`ã‚’å¸¸ã«`%{status: 500}`ã‚’è¿”ã™åˆ¥ã®é–¢æ•°ã«å·®ã—æ›¿ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

<!-- livebook:{"break_markdown":true} -->

![](images/image_of_mocking.png)

```elixir
defmodule HttpBin do
  # HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è¡Œã†ãŸã‚ã®äº‹å‰æº–å‚™
  HTTPoison.start()

  @endpoint "https://httpbin.org"

  def send_request(method, body_map, header_map) do
    url = @endpoint <> "/#{method}"

    case HTTPoison.post!(url, Jason.encode!(body_map), header_map) do
      %HTTPoison.Response{body: res_body, status_code: 200} ->
        %{status: 200, body: Jason.decode!(res_body)}

      %HTTPoison.Response{status_code: 500} ->
        %{status: 500}
    end
  end
end
```

<!-- livebook:{"continue_on_error":true} -->

```elixir
HttpBin.send_request(:post, %{foo: "bar"}, %{"Content-Type" => "application/json"})
```

meckãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦`Http.send_request/3`ãŒå¸¸ã«`%{status: 500}`ã‚’è¿”ã™ã‚ˆã†æŒ¯ã‚‹èˆã„ã‚’å¤‰ãˆã‚‹ã€‚

```elixir
# Erlangã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã¯ã€atomã§è¡¨ã™æ±ºã¾ã‚Šã«ãªã£ã¦ã„ã‚‹ => :meck

# ãƒ¢ãƒƒã‚¯ã™ã‚‹ãŸã‚ã®äº‹å‰æº–å‚™
:meck.new(HttpBin, [:passthrough])
```

```elixir
# HttpBin.send_request/3 ã‚’ä»»æ„ã®é–¢æ•°ã«å·®ã—æ›¿ãˆã‚‹
:meck.expect(
  # å¯¾è±¡ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
  HttpBin,
  # é–¢æ•°åã®atom
  :send_request,
  # é–¢æ•°ã¨åŒã˜arityã‚’æŒã¤ç„¡åé–¢æ•°
  fn _method, _body, _header -> %{status: 500} end
)
```

```elixir
HttpBin.send_request(:post, %{foo: "bar"}, %{"Content-Type" => "application/json"})
```

`Http.send_request/3`ã®æŒ¯ã‚‹èˆã„ãŒç„¡åé–¢æ•°`fn _method, _body, _header -> %{status: 500} end`ã«å·®ã—æ›¿ã‚ã£ãŸã‚ˆã†ã !

æœ¬å½“ã«ãã†ãªã®ã‹ã€ã•ã‚‰ã«ç¢ºã‹ã‚ã¦ã¿ã‚ˆã†ã€‚

```elixir
:meck.expect(HttpBin, :send_request, fn method, _body, _header ->
  IO.puts("Mocked function is called ğŸ˜")
  IO.puts("Tried to request by #{method} method")
  %{status: 500}
end)
```

```elixir
HttpBin.send_request(:post, %{foo: "bar"}, %{"Content-Type" => "application/json"})
```

ğŸ˜

ãƒ¢ãƒƒã‚¯ã¯ä»–ã®å‰¯ä½œç”¨ã€ä¾‹ãˆã°æ—¥æ™‚ã‚„ä¹±æ•°ãŒé–¢ã‚ã‚‹ã‚ˆã†ãªãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½ã™ã‚‹éš›ã«ã‚‚ã‚ˆãä½¿ã‚ã‚Œã‚‹ã€‚

```elixir
# ãƒ¢ãƒƒã‚¯ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‰Šé™¤
:meck.unload(HttpBin)
```
